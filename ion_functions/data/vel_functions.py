#!/usr/bin/env python
"""
@package ion_functions.data.vel_functions
@file ion_functions/data/vel_functions.py
@author Stuart Pearce
@brief Module containing velocity family instrument related functions
"""

import numpy as np
import numexpr as ne
from numpy import sin, cos, radians

from ion_functions.data.generic_functions import magnetic_declination, magnetic_correction

# NOTE:
#    The previous version of this module had each function return an
#    array of all fill values (-9999) if the lat or lon is invalid. This
#    should not occur. Really lat and lon should be checked and handled
#    in the QAQC functions, and only apply a fill value for the single
#    instance of invalid lat & lon rather than the whole array. I
#    believe they were coded here for testing purposes. The part that
#    returned the fill values now instead just raises the ValueError
#    exception.
#               -Stuart Pearce
#               (this message should be removed if/when the lats & lons
#               are checked in the QAQC functions)
from exceptions import ValueError

### Constants ###
# XYZ_TRANSFORMS is a dictionary constant that is generated when the
# module is first imported. XYZ_TRANSFORMS is generated by the
# generate_beam_transforms function and must be created after the
# function is declared. Therefore XYZ_TRANSFORMS is not here in the
# constants section.


# wrapper functions for use in ION
def nobska_mag_corr_east(u, v, lat, lon, timestamp, z=0):
    """
    Corrects the eastward velocity from a VEL3D-B Nobska MAVS 4
    instrument for magnetic declination to produce an L1 VELPTTU-VLE
    OOI data product.

    Given a velocity vector with components u & v in the magnetic East
    and magnetic North directions respectively, this function calculates
    the magnetic declination for the location, depth, and time of the
    vector from the World Magnetic Model (WMM) and transforms the vector
    to a true Earth reference frame.

    This function is a wrapper around the function "vel_mag_correction".

    Usage:

        u_cor = nobska_mag_corr_east(u, v, lat, lon, ntp_timestamp, z=0)

            where

        u_cor = eastward velocity, in true Earth frame, with the
            correction for magnetic declination applied. [m/s]

        u = uncorrected eastward velocity in magnetic Earth frame. [cm/s]
        v = uncorrected northward velocity in magnetic Earth frame. [cm/s]
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth of instrument relative to sea level [meters].
            Positive values only. Default value is 0.

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00781.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00781_Data_Product_SPEC_VELPTTU_Nobska_OOI.pdf)
    """
   # Check for valid latitudes & longitudes
    if not valid_lat(lat) or not valid_lon(lon):
        # commented out next line according to NOTE above. -SP
        #return np.ones(u.shape, dtype=np.float) * -9999
        raise ValueError('Latitudes or Longitudes are not within the valid range!')

    # correct for magnetic declination
    u_cor = vel_mag_correction(u, v, lat, lon, timestamp, z)[0]
    u_cor = ne.evaluate('u_cor / 100.')  # convert from cm/s to m/s

    # return true compass referenced East velocity in m/s
    return u_cor


def nobska_mag_corr_north(u, v, lat, lon, timestamp, z=0):
    """
    Corrects the northward velocity from a VEL3D-B Nobska MAVS 4
    instrument for magnetic declination to produce an L1 VELPTTU-VLN
    OOI data product.

    Given a velocity vector with components u & v in the magnetic East
    and magnetic North directions respectively, this function calculates
    the magnetic declination for the location, depth, and time of the
    vector from the World Magnetic Model (WMM) and transforms the vector
    to a true Earth reference frame.

    This function is a wrapper around the function "vel_mag_correction".

    Usage:

        v_cor = nobska_mag_corr_north(u, v, lat, lon, ntp_timestamp, z)

            where

        v_cor = northward velocity, in true Earth frame, with the
            correction for magnetic declination applied. [m/s]

        u = uncorrected eastward velocity in magnetic Earth frame. [cm/s]
        v = uncorrected northward velocity in magnetic Earth frame. [cm/s]
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth of instrument relative to sealevel [meters].
            Positive values only. Default value is 0.

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00781.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00781_Data_Product_SPEC_VELPTTU_Nobska_OOI.pdf)
    """
   # check for valid latitudes & longitudes
    if not valid_lat(lat) or not valid_lon(lon):
        # commented out next line according to NOTE above. -SP
        #return np.ones(u.shape, dtype=np.float) * -9999
        raise ValueError('Latitudes or Longitudes are not within the valid range!')

    # correct for magnetic declination
    v_cor = vel_mag_correction(u, v, lat, lon, timestamp, z)[1]
    v_cor = ne.evaluate('v_cor / 100.')  # convert from cm/s to m/s

    # return true compass referenced North velocity in m/s
    return v_cor


def nobska_scale_up_vel(w):
    """
    Converts a Nobska MAVS-4 (VEL3D-B) vertical velocity measurement
    from cm/s to m/s

    Usage:

        w_mps = nobska_scale_up_vel(w_cmps)

            where

        w_mps = Output vertical velocity. [m/s]
        w_cmps = Input vertical velocity. [cm/s]

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00781.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00781_Data_Product_SPEC_VELPTTU_Nobska_OOI.pdf)
    """
    return w / 100.0


def nortek_mag_corr_east(u, v, lat, lon, timestamp, z=0.0):
    """
    Corrects the eastward velocity from VEL3D-CD Nortek Vector, VEL3D-K
    Nortek Aquadopp II, or VELPT Nortek Aquadopp instruments for
    magnetic declination to produce an L1 VELPTTU-VLE or an L1
    VELPTMN-VLE OOI data product.

    Given a velocity vector with components u & v in the magnetic East
    and magnetic North directions respectively, this function calculates
    the magnetic declination for the location, depth, and time of the
    vector from the World Magnetic Model (WMM) and transforms the vector
    to a true Earth reference frame.

    This function is a wrapper around the function "vel_mag_correction".

    Usage:

        u_cor = nortek_mag_corr_east(u, v, lat, lon, ntp_timestamp, z)

            where

        u_cor = eastward velocity , in true Earth frame, with the
            correction for magnetic declination applied. [m/s]

        u = uncorrected eastward velocity in magnetic Earth frame. [m/s]
        v = uncorrected northward velocity in magnetic Earth frame. [m/s]
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth of instrument relative to sealevel [meters].
            Positive values only. Default value is 0.

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00780.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00780_Data_Product_SPEC_VELPTTU_Nortek_OOI.pdf)
    """
   # check for valid latitudes & longitudes
    if not valid_lat(lat) or not valid_lon(lon):
        # commented out next line according to NOTE above. -SP
        #return np.ones(u.shape, dtype=np.float) * -9999
        raise ValueError('Latitudes or Longitudes are not within the valid range!')

    # correct for magnetic declination
    u_cor = vel_mag_correction(u, v, lat, lon, timestamp, z)[0]

    # return true compass referenced East velocity in m/s
    return u_cor


def nortek_mag_corr_north(u, v, lat, lon, timestamp, z=0.0):
    """
    Corrects the northward velocity from VEL3D-CD Nortek Vector, VEL3D-K
    Nortek Aquadopp II, and VELPT Nortek Aquadopp instruments for
    magnetic declination to produce an L1 VELPTTU-VLN or an L1
    VELPTMN-VLN OOI data product.

    Given a velocity vector with components u & v in the magnetic East
    and magnetic North directions respectively, this function calculates
    the magnetic declination for the location, depth, and time of thel
    vector from the World Magnetic Model (WMM) and transforms the vector
    to a true Earth reference frame.

    This function is a wrapper around the function "vel_mag_correction".

    Usage:

        v_cor = nortek_mag_corr_north(u, v, lat, lon, ntp_timestamp, z)

            where

        v_cor = northward velocity, in true Earth frame, with the
            correction for magnetic declination applied. [m/s]

        u = uncorrected eastward velocity in magnetic Earth frame. [m/s]
        v = uncorrected northward velocity in magnetic Earth frame. [m/s]
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth of instrument relative to sealevel [meters].
            Positive values only. Default value is 0.

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00780.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00780_Data_Product_SPEC_VELPTTU_Nortek_OOI.pdf)
    """
   # check for valid latitudes & longitudes
    if not valid_lat(lat) or not valid_lon(lon):
        # commented out next line according to NOTE above. -SP
        #return np.ones(u.shape, dtype=np.float) * -9999
        raise ValueError('Latitudes or Longitudes are not within the valid range!')

    # correct for magnetic declination
    v_cor = vel_mag_correction(u, v, lat, lon, timestamp, z)[1]

    # return true compass referenced North velocity in m/s
    return v_cor


def nortek_up_vel(w):
    """
    Returns a Nortek instrument (VEL3D-C,D,K or VELPT) vertical velocity
    measurement. This function is an identity function to return the
    same value, but is required because of how OOINet and OOI have
    designated the system to work.

    Usage:

        w = nortek_up_vel(w)

            where

        w = Output and Input vertical velocity.  [m/s]

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00781.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00781_Data_Product_SPEC_VELPTTU_Nobska_OOI.pdf)
    """
    return w


def vel3dk_east(
        vel0, vel1, vel2, heading, pitch, roll, beams, lat, lon,
        timestamp, z, Vscale, vel3=0):
    """Eastward Velocity L1 VELPTTU-VLE in True Earth coordinates

    Transforms beam velocities to Earth coordinate velocities and then
    corrects for magnetic declination to produce the true Earth frame
    eastward velocity as the L1 VELPTTU-VLE OOI data product.

    Takes 3 or 4 beam velocities in integer counts from a VEL3D-K
    (Aquadopp II on a McLane Profiler(MMP)) with the provided Vscale,
    beam configuration parameters, and attitude orientation (heading,
    pitch, and roll) data from an MMP A#####.DEC binary data file.

    Given velocities in beam coordinates in the configuration provided
    by the beam parameters, this function transforms the beam velocities
    to magnetic Earth coordinates (East, North, and Up). Then the East
    and North velocity vectors (u & v) are corrected for magnetic
    declination for the location, depth, and time of the vectors using
    the World Magnetic Model (WMM), transforming the vectors to a true
    Earth reference frame.

    This function is a wrapper around the functions "vel_mag_correction"
    and "vel3dk_transform".

    Usage:
        u_cor = vel3dk_east(
            vel0, vel1, vel2, heading, pitch, roll, beam1, beam2, beam3,
            beam4, lat, lon, timestamp, z, Vscale, vel3=0)

            where

        u_cor = floating point eastward velocity, in true Earth frame,
            with the correction for magnetic declination applied. [m/s]

        vel0, 1, 2, 3 = AquadoppII beam velocities as integers to be
            scaled by 10^Vscale. vel3 is optional depending on the
            number of beams used as listed in beams.
            [scaled integer distance/s]
        heading, pitch, roll = attitude data obtained from the
            AquadoppII.  [degrees]
        beams = the beam configuration array listing the physical beams
            used that correspond to velocities vel0-3
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth of instrument relative to sealevel [meters].
            Positive values only. Default value is 0.
        Vscale = velocity scaling exponent factor.

    References:

        VEL3D-K IDD (2014) (No DPS as of 2014-03-03)
        https://confluence.oceanobservatories.org/display/instruments/
        VEL3D-K__stc_imodem+-+Telemetered

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00780.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00780_Data_Product_SPEC_VELPTTU_Nortek_OOI.pdf)
    """
    # convert from scaled, integer distance/s (as received from the
    # binary data file) to floating point m/s using the Vscale parameter
    # from the MMP binary data file A#####.DEC
    vel0 = vel0 * 10**Vscale
    vel1 = vel1 * 10**Vscale
    vel2 = vel2 * 10**Vscale
    if vel3 != 0:
        vel3 = vel3 * 10**Vscale

   # check for valid latitudes & longitudes
    if not valid_lat(lat) or not valid_lon(lon):
        raise ValueError('Latitudes or Longitudes are not within the valid range!')

    # transform beam velocites in spherical coordinates to Earth
    # coordinates using beam configuration and instrument attitude.
    if vel3 != 0:
        ENU = vel3dk_transform(
            vel0, vel1, vel2, heading, pitch, roll, beams, vel3)
    else:
        ENU = vel3dk_transform(
            vel0, vel1, vel2, heading, pitch, roll, beams)

    # separate out the components from the Earth coordinate transformed
    # data matrix. The zero index is needed since matrix is
    # automatically 2-D, must change back to a 1-D array.
    u = np.array(ENU[0, :])[0]
    v = np.array(ENU[1, :])[0]

    # correct for magnetic declination
    u_cor = vel_mag_correction(u, v, lat, lon, timestamp, z)[0]

    # return true compass referenced East velocity in m/s
    #   the zero index is needed here because the vel3dk
    return u_cor


def vel3dk_north(
        vel0, vel1, vel2, heading, pitch, roll, beams, lat, lon,
        timestamp, z, Vscale, vel3=0):
    """Northward Velocity L1 VELPTTU-VLN in True Earth coordinates

    Transforms beam velocities to Earth coordinate velocities and then
    corrects for magnetic declination to produce the true Earth frame
    northward velocity as the L1 VELPTTU-VLN OOI data product.

    Takes 3 or 4 beam velocities in integer counts from a VEL3D-K
    (Aquadopp II on a McLane Profiler(MMP)) with the provided Vscale,
    beam configuration parameters, and attitude orientation (heading,
    pitch, and roll) data from an MMP A#####.DEC binary data file.

    Given velocities in beam coordinates in the configuration provided
    by the beam parameters, this function transforms the beam velocities
    to magnetic Earth coordinates (East, North, and Up). Then the East
    and North velocity vectors (u & v) are corrected for magnetic
    declination for the location, depth, and time of the vectors using
    the World Magnetic Model (WMM), transforming the vectors to a true
    Earth reference frame.

    This function is a wrapper around the functions "vel_mag_correction"
    and "vel3dk_transform".

    Usage:
        v_cor = vel3dk_north(
            vel0, vel1, vel2, heading, pitch, roll, beams, lat, lon,
            ntp_timestamp, z, Vscale, vel3=0)

            where

        v_cor = floating point northward velocity, in true Earth frame,
            with the correction for magnetic declination applied. [m/s]

        vel0, 1, 2, 3 = AquadoppII beam velocities as integers to be
            scaled by 10^Vscale. vel3 is optional depending on the
            number of beams used as listed in beams.
            [scaled integer distance/s]
        heading, pitch, roll = attitude data obtained from the
            AquadoppII.  [degrees]
        beams = the beam configuration array listing the physical beams
            used that correspond to velocities vel0-3
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth of instrument relative to sealevel [meters].
            Positive values only. Default value is 0.
        Vscale = velocity scaling exponent factor.

    References:

        VEL3D-K IDD (2014) (No DPS as of 2014-03-03)
        https://confluence.oceanobservatories.org/display/instruments/
        VEL3D-K__stc_imodem+-+Telemetered

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00780.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00780_Data_Product_SPEC_VELPTTU_Nortek_OOI.pdf)
    """
    # convert from scaled, integer distance/s (as received from the
    # binary data file) to floating point m/s using the Vscale parameter
    # from the MMP binary data file A#####.DEC
    vel0 = vel0 * 10**Vscale
    vel1 = vel1 * 10**Vscale
    vel2 = vel2 * 10**Vscale
    if vel3 != 0:
        vel3 = vel3 * 10**Vscale

   # check for valid latitudes & longitudes
    if not valid_lat(lat) or not valid_lon(lon):
        raise ValueError('Latitudes or Longitudes are not within the valid range!')

    # transform beam velocites in spherical coordinates to Earth
    # coordinates using beam configuration and instrument attitude.
    if vel3 != 0:
        ENU = vel3dk_transform(
            vel0, vel1, vel2, heading, pitch, roll, beams, vel3)
    else:
        ENU = vel3dk_transform(
            vel0, vel1, vel2, heading, pitch, roll, beams)

    # separate out the components from the Earth coordinate transformed
    # data matrix. The zero index is needed since matrix is
    # automatically 2-D, must change back to a 1-D array.
    u = np.array(ENU[0, :])[0]
    v = np.array(ENU[1, :])[0]

    # correct for magnetic declination
    v_cor = vel_mag_correction(u, v, lat, lon, timestamp, z)[1]

    # return true compass referenced East velocity in m/s
    return v_cor


def vel3dk_up(
        vel0, vel1, vel2, heading, pitch, roll, beams, Vscale, vel3=0):
    """
    Takes an integer vertical velocity in generic distance per second
    units from a VEL3D-K (Aquadopp II on a McLane Profiler(MMP)) with
    the provided Vscale parameter from an MMP A#####.DEC binary data
    file to scale the velocity to a floating point in m/s.

    Usage:
        w_mps = vel3dk_up(
                    vel0, vel1, vel2, heading, pitch, roll,
                    beams, Vscale, vel3=0)

            where

        w_mps = floating point vertical velocity. [m/s]

        vel0, 1, 2, 3 = AquadoppII beam velocities as integers to be
            scaled by 10^Vscale. vel3 is optional depending on the
            number of beams used as listed in beams.
            [scaled integer distance/s]
        Vscale = velocity scaling exponent factor.
        heading, pitch, roll = the attitude information from the instrument
        beam1, 2, 3, 4 = beam configuration describes the physical beam
                used for vel0-3

    References:

        VEL3D-K IDD (2014) (No DPS as of 2014-03-03)
        https://confluence.oceanobservatories.org/display/instruments/
        VEL3D-K__stc_imodem+-+Telemetered
    """
    # convert from scaled, integer distance/s (as received from the
    # binary data file) to floating point m/s using the Vscale parameter
    # from the MMP binary data file A#####.DEC
    vel0 = vel0 * 10**Vscale
    vel1 = vel1 * 10**Vscale
    vel2 = vel2 * 10**Vscale
    if vel3 != 0:
        vel3 = vel3 * 10**Vscale

    # transform the beam velocities to Earth coordinates
    if vel3 != 0:
        ENU = vel3dk_transform(
            vel0, vel1, vel2, heading, pitch, roll, beams, vel3)
    else:
        ENU = vel3dk_transform(
            vel0, vel1, vel2, heading, pitch, roll, beams)

    # seperate out the components from the
    w = ENU[2, :]

    # return vertical velocity in m/s
    return w


##### Sub functions #####
## magnetic correction subfunction
def vel_mag_correction(u, v, lat, lon, ntp_timestamp, z=0.0, zflag=-1):
    """
    Description:

        Given a velocity vector U, measured in a sensor frame that is
        referenced to Earth's magnetic field, with components u & v in
        the magnetic East and magnetic North directions respectively;
        vel_mag_correction transforms U to true Earth referenced
        directions by a rotation that removes the magnetic declination.
        Magnetic Declination, theta(x,y,z,t), is the azimuthal angular
        offset between true North and magnetic North as a function of
        Earth referenced location (latitude, longitude, & height/depth)
        and time. Magnetic declination is estimated from the World
        Magnetic Model (WMM) using the location and time of the vector.

    Usage:

        u_cor, v_cor = vel_mag_correction(u, v, lat, lon, ntp_timestamp, z, zflag)

            where

        u_cor = eastward velocity, in true Earth frame, with the
            correction for magnetic declination applied.
        v_cor = northward velocity, in true Earth frame, with the
            correction for magnetic declination applied.

        u = uncorrected eastward velocity in magnetic Earth frame.
        v = uncorrected northward velocity in magnetic Earth frame.
        lat = latitude of the instrument [decimal degrees].  East is
            positive, West negative.
        lon = longitude of the instrument [decimal degrees]. North
            is positive, South negative.
        ntp_timestamp = NTP time stamp from a data particle
            [secs since 1900-01-01].
        z = depth or height of instrument relative to sealevel [meters].
            Positive values only. Default value is 0.
        zflag = indicates whether to use z as a depth or height relative
            to sealevel. -1=depth (i.e. -z) and 1=height (i.e. +z). -1
            is the default, because Oceanography!

    Implemented by:

        2013-04-17: Stuart Pearce. Initial code.
        2013-04-24: Stuart Pearce. Changed to be general for all velocity
                    instruments.
        2014-02-05: Christopher Wingard. Edited to use magnetic corrections in
                    the generic_functions module.

    References:

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00781.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00781_Data_Product_SPEC_VELPTTU_Nobska_OOI.pdf)

        OOI (2012). Data Product Specification for Turbulent Point Water
            Velocity. Document Control Number 1341-00780.
            https://alfresco.oceanobservatories.org/ (See: Company Home
            >> OOI >> Controlled >> 1000 System Level >>
            1341-00780_Data_Product_SPEC_VELPTTU_Nortek_OOI.pdf)
    """
    # retrieve the magnetic declination
    theta = magnetic_declination(lat, lon, ntp_timestamp, z, zflag)

    # apply the magnetic declination correction
    magvar = np.vectorize(magnetic_correction)
    u_cor, v_cor = magvar(theta, u, v)

    return u_cor, v_cor


## VEL3D-K Beam coordinate transformations ##
def generate_beam_transforms():
    """
    Description:
        This function is used to create the 3 possible beam-to-cartesian
        coordinate transform matrices that transforms velocity vectors
        from beam coordinates of the Nortek Aquadopp II velocity
        instrument (VEL3D-K), to the cartesian coordinates of the McLane
        Moored Profiler (Wire Following Profiler [WFP]). The transform
        used depends on the beams used by the Aquadopp II during a
        profile. The spherical coordinates for the 4 beams on the
        instrument and the orientation of the instrument on the profiler
        are hard coded here (never expected to change) for processing
        ease i.e. no required inputs to the function.

        The 3 possible beam configurations are an upward traveling
        profile (using 3 of 4 beams), a downward traveling profile
        (using 3 of 4 beams), or a stationary profile (using 4 of 4
        beams). These 3 transform matrices are returned in a dictionary
        that is loaded into the module as a constant for use in the
        actual transformation functions. The dictionary keys are
        'upward', 'downward', or 'stationary'.

    Implemented by:
        2014-05-13: Stuart Pearce. Reimplementation of code from P.J.
            Rusello at Nortek

    References:
        Lengthy discussions with Nortek and McLane representatives.  No
        DPS as of yet.
    """
    ## INTERNAL DESCRIPTION:
    ## First a matrix that transforms the velocities from cartesian
    ## coordinates to spherical beam coordinates is created (identified
    ## by the xyz2beam). To find the reverse matrix that transforms the
    ## velocities from spherical beams to cartesian coordinates, the
    ## inverse of the first matrix must be found (identified by
    ## beam2xyz). This is known as a "Change of basis". The permutation
    ## matrix then transforms the velocities from cartesian coordianates
    ## of the instrument, to cartesian coordinates of the profiler. The
    ## permutation matrix is muliplied by the beam2xyz to get the single
    ## transformation matrix beam2XYZ (capital XYZ indicates cartesian
    ## coordinates of the profiler). To get to Earth coordinates,
    ## another transformation matrix that reverses heading, pitch, and
    ## roll must be made, but that occurs in another function.

    # BEAMS dictionary is the rotations for each beam from cartesian
    # coordinates to spherical coordinates
    BEAMS = {
        1: (sin(radians(47.5)) * cos(radians(0.0)),
            0.0,  # sin(47.5 deg)*sin(0 deg) = 0
            cos(radians(47.5))),
        2: (0.0,  # sin(25 deg)*cos(90 deg) = 0
            sin(radians(25.0)) * sin(radians(90.0)),
            cos(radians(25.0))),
        3: (sin(radians(47.5)) * cos(radians(180.0)),
            0.0,  # sin(47.5 deg)*sin(180 deg) = 0
            cos(radians(47.5))),
        4: (0.0,  # sin(25 deg)*cos(270 deg) = 0
            sin(radians(25.0)) * sin(radians(270.0)),
            cos(radians(25.0)))}

    # the cartesian to beam transforms
    upward_xyz2beam = np.matrix([BEAMS[1], BEAMS[2], BEAMS[4]])
    downward_xyz2beam = np.matrix([BEAMS[2], BEAMS[3], BEAMS[4]])
    stationary_xyz2beam = np.matrix([
        [BEAMS[1][0], BEAMS[1][1], BEAMS[1][2], 0.0],
        [BEAMS[2][0], BEAMS[2][1], 0.0, BEAMS[2][2]],
        [BEAMS[3][0], BEAMS[3][1], BEAMS[3][2], 0.0],
        [BEAMS[4][0], BEAMS[4][1], 0.0, BEAMS[4][2]]])

    # get the inverse of the transforms
    upward_beam2xyz = np.linalg.pinv(upward_xyz2beam)
    downward_beam2xyz = np.linalg.pinv(downward_xyz2beam)
    stationary_beam2xyz = np.linalg.pinv(stationary_xyz2beam)

    # set ~0 float point errors to zero
    upward_beam2xyz[abs(upward_beam2xyz) < 1e-15] = 0.0
    downward_beam2xyz[abs(downward_beam2xyz) < 1e-15] = 0.0
    stationary_beam2xyz[abs(stationary_beam2xyz) < 1e-15] = 0.0

    # create permutation matrices
    permutation_matrix3 = np.matrix([  # if 3 beams are used
        [0,  0, 1],
        [0, -1, 0],
        [1,  0, 0]
    ])
    permutation_matrix4 = np.matrix([  # if 4 beams are used
        [0,  0, 0.5, 0.5],
        [0, -1,   0,   0],
        [1,  0,   0,   0]
    ])

    # combine to create the beam2XYZ (profiler cartesian) transformation
    T_beam2XYZ_up = permutation_matrix3 * upward_beam2xyz
    T_beam2XYZ_down = permutation_matrix3 * downward_beam2xyz
    T_beam2XYZ_stat = permutation_matrix4 * stationary_beam2xyz

    beam2XYZ_transforms = {'upward': T_beam2XYZ_up,
                           'downward': T_beam2XYZ_down,
                           'stationary': T_beam2XYZ_stat}

    return beam2XYZ_transforms


# XYZ_TRANSFORMS constant created here
XYZ_TRANSFORMS = generate_beam_transforms()


def get_XYZ_transform(beamlist):
    """
    Sub-function that retrieves the proper beam-to-profiler-cartesian
    coordinates from the stored dictionary constant based on the beam
    configuration for a profile.

    Usage:
        beam2XYZ_transform = get_XYZ_transform(beamlist)

        where

        beam2XYZ_transform = the beam-to-profiler-cartesian transform
            matrix
        beamlist = a list (derived from the data file) that describes
            the physical beams used in order.  E.g. [1, 2, 4, 0]

    """
    ## Implemented by:
    ## 2014-05-13: Stuart Pearce. Reimplementation of code from P.J.
    ##     Rusello at Nortek
    if beamlist == [1, 2, 3, 4]:
        t_beam2XYZ = XYZ_TRANSFORMS['stationary']
    elif beamlist == [1, 2, 4, 0]:
        t_beam2XYZ = XYZ_TRANSFORMS['upward']
    elif beamlist == [2, 3, 4, 0]:
        t_beam2XYZ = XYZ_TRANSFORMS['downward']

    return t_beam2XYZ


def generate_ENU_transform(heading, pitch, roll):
    """
    Description:
        This function is used to create the cartesian-to-Earth
        coordinate transform matrices that transforms velocity vectors
        from cartesian coordinates of a McLane Profiler (with a Nortek
        Aquadopp II velocity instrument (VEL3D-K)), to Earth coordinates
        using heading, pitch, and roll data from the attitude sensor on
        board the Aquadopp II.

    Usage:
        XYZ2Earth_trans = generate_ENU_transform(heading, pitch, roll)

        where

        XYZ2Earth_trans = the cartesian-to-Earth coordinate tranform
            matrix
        heading, pitch, roll = the attitude measurements by the Aquadopp
            II velocity instrument.

    Implemented by:
        2014-05-13: Stuart Pearce. Reimplementation of code from P.J.
            Rusello at Nortek

    References:
        Lengthy discussions with Nortek and McLane representatives.  No
        DPS as of yet.

        Definitions of rotation matrices taken from Freescale Technical
        Note Implementing a Tilt-Compensated eCompass using
        Accelerometer and Magnetometer Sensors
        http://cache.freescale.com/files/sensors/doc/app_note/AN4248.pdf
    """

    heading = np.radians(heading)
    # need to make pitch and roll angles negative so that rotation matrices
    # effectively unpitch and unroll the data
    pitch = np.radians(-1.0 * pitch)
    roll = np.radians(-1.0 * roll)

    # "un"-roll transform matrix
    Rx = np.matrix([
        [1.0, 0.0, 0.0],
        [0.0, cos(roll), sin(roll)],
        [0.0, -sin(roll), cos(roll)]]
    )
    # "un"-pitch transform matrix
    Ry = np.matrix([
        [cos(pitch), 0.0, -sin(pitch)],
        [0.0, 1.0, 0.0],
        [sin(pitch), 0.0, cos(pitch)]]
    )
    # "un"-heading transform matrix
    Rz = np.matrix([
        [cos(heading), sin(heading), 0.0],
        [-sin(heading), cos(heading), 0.0],
        [0.0, 0.0, 1.0]]
    )

    # multiply together to create the XYZ to Earth coordinate transform
    XYZ2ENU = Rz * Ry * Rx
    return XYZ2ENU


def vel3dk_transform(
        vel0, vel1, vel2, heading, pitch, roll, beams, vel3=0):
    """
    Description:
        Transforms beam velocities to Earth coordinate velocities for an
        OOI VEL3D-K instrument.

        Takes 3 or 4 beam velocities in m/s from a VEL3D-K
        (Aquadopp II on a McLane Profiler(MMP)), a beam configuration
        array, and attitude orientation data (heading, pitch, and roll),
        and transforms the velocities from beam coordinates to Earth
        coordinates in the East, North, and Upwards directions.

    Usage:
        ENU = vel3dk_transform(vel0, vel1, vel2, heading, pitch, roll,
                               beams, vel3=0)

        where

        ENU = A matrix of velocity data in Earth coordinates (East,
            North, Up) with East velocities in the first row, North
            velocities in the second row and Upward velocities in the
            3rd row.
        vel0, 1, 2, 3 = AquadoppII beam velocities as integers to be
            scaled by 10^Vscale. vel3 is optional depending on the
            number of beams used as listed in beams.
            [scaled integer distance/s]
        heading, pitch, roll = attitude data obtained from the
            AquadoppII.  [degrees]
        beams = the beam configuration array listing the physical beams
            used that correspond to velocities vel0-3

    Implemented by:
        2014-05-13: Stuart Pearce. Reimplementation of code from P.J.
            Rusello at Nortek

    References:
        Lengthy discussions with Nortek and McLane representatives.  No
        DPS as of yet.
    """
    data = np.matrix([vel0, vel1, vel2])
    if vel3 != 0:
        data[4, :] = vel3

    beams_used = list(beams[0, :])
    t_beam2XYZ = get_XYZ_transform(beams_used)

    ENU = np.matrix(np.zeros_like(data))  # East, North, Up velocities

    # need a transformation matrix for each measurement
    # because Heading Pitch & Roll will change with each record
    for ii in range(len(heading)):
        if list(beams[ii, :]) != beams_used:
            beams_used = list(beams[ii, :])
            t_beam2XYZ = get_XYZ_transform(beams_used)
        t_XYZ2ENU = generate_ENU_transform(heading[ii], pitch[ii], roll[ii])
        ENU[:, ii] = t_XYZ2ENU * t_beam2XYZ * data[:, ii]
    return ENU


# helper sub-functions
def valid_lat(lat):
    """valid_lat(lat) -> boolean

    Checks if inputs are valid latitude values.
    Returns True if value is between -90 and 90,
    False otherwise.
    """
    if isinstance(lat, np.ndarray):
        if np.any(lat > 90) or np.any(lat < -90):
            return False
        return True
    else:
        return -90 <= lat and lat <= 90


def valid_lon(lon):
    """valid_lon(lon) -> boolean

    Checks if inputs are valid longitude values.
    Returns True if value is between -180 and 180,
    False otherwise.
    """
    if isinstance(lon, np.ndarray):
        if np.any(lon > 180) or np.any(lon < -180):
            return False
        return True
    else:
        return -180 <= lon and lon <= 180
